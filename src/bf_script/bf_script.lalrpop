use std::str::FromStr;
use crate::bf_script::ast::{Expression, Opcode, Statement};
use lalrpop_util::ParseError;

grammar;


match {
    r"[0-9]+" => NUMBER,
    r"[a-zA-Z_]\w*" => ID,
    r#""[^"]*""# => STRING,

    _, 

    // Skip whitespace and comments
    r"\s*" => { },
    r"//[^\n\r]*[\n\r]*" => { }, // `// comment`
    r"/\*([^\*]*\*+[^\*/])*([^\*]*\*+|[^\*])*\*/" => { }, // `/* comment */`
}

pub Program : Vec<Statement<'input>> = {
    <Statement*>,
}

Statement: Statement<'input> = {
    VarDeclaration,
    "{" <s:Statement+> "}" => Statement::Block(s),
};

VarDeclaration: Statement<'input> = {
    "var" <n:Identifier> "=" <i: Expression> ";" => Statement::VarDeclaration(n, vec![i]),
    "var" <n:Identifier> "[" "]" "=" "[" <mut i: (<Expression> ",")+> <t:Expression> "]" ";" => {
        i.push(t);
        Statement::VarDeclaration(n, i)
    },
    "var" <n:Identifier> "[" "]" "=" <i:StringLiteral> ";" =>
        Statement::VarDeclaration(n, i.chars().map(|c| Expression::Literal(c as i32)).collect()),
};

StringLiteral: &'input str = {
    <l:STRING> => l[1..l.len() -1].into()
}

Expression = Assignment;

Assignment: Expression<'input> = {
    <n:Identifier> <i:("[" <Expression> "]")?> "=" <v:LogicOr> => match i {
        Some(index) => Expression::IndexedAssignment(n, Box::new(index), Box::new(v)),
        None => Expression::Assignment(n, Box::new(v)),
    },
    LogicOr,
}

LogicOr: Expression<'input> = {
    <l:LogicOr> <o:"||"> <r:LogicAnd> => Expression::Binary(Box::new(l), o.into(), Box::new(r)),
    LogicAnd,
}

LogicAnd: Expression<'input> = {
    <l:LogicAnd> <o:"&&"> <r:Equality> => Expression::Binary(Box::new(l), o.into(), Box::new(r)),
    Equality,
}

Equality: Expression<'input> = {
    <l:Equality> <o:"!="> <r:Comparison> => Expression::Binary(Box::new(l), o.into(), Box::new(r)),
    <l:Equality> <o:"=="> <r:Comparison> => Expression::Binary(Box::new(l), o.into(), Box::new(r)),
    Comparison,
}

Comparison: Expression<'input> = {
    <l:Comparison> <o:">"> <r:Addition> => Expression::Binary(Box::new(l), o.into(), Box::new(r)),
    <l:Comparison> <o:">="> <r:Addition> => Expression::Binary(Box::new(l), o.into(), Box::new(r)),
    <l:Comparison> <o:"<"> <r:Addition> => Expression::Binary(Box::new(l), o.into(), Box::new(r)),
    <l:Comparison> <o:"<="> <r:Addition> => Expression::Binary(Box::new(l), o.into(), Box::new(r)),
    Addition,
};

Addition: Expression<'input> = {
    <l:Addition> <o:"+"> <r:Multiplication> => Expression::Binary(Box::new(l), o.into(), Box::new(r)),
    <l:Addition> <o:"-"> <r:Multiplication> => Expression::Binary(Box::new(l), o.into(), Box::new(r)),
    Multiplication,
};

Multiplication: Expression<'input> = {
    <l:Multiplication> <o:"*"> <r:Unary> => Expression::Binary(Box::new(l), o.into(), Box::new(r)),
    <l:Multiplication> <o:"/"> <r:Unary> => Expression::Binary(Box::new(l), o.into(), Box::new(r)),
    <l:Multiplication> <o:"%"> <r:Unary> => Expression::Binary(Box::new(l), o.into(), Box::new(r)),
    Unary,
};

Unary: Expression<'input> = {
    <o:"!"> <e:Unary> => Expression::Unary(o.into(), Box::new(e)),
    <o:"-"> <e:Unary> => Expression::Unary(o.into(), Box::new(e)),
    <o:"+"> <e:Unary> => e,
    Primary,
}


Primary: Expression<'input> = {
    NUMBER => Expression::Literal(i32::from_str(<>).unwrap()),
    <n:Identifier> <i:("[" <Expression> "]")?> => match i {
        None => Expression::Variable(n),
        Some(index) => Expression::IndexedVariable(n, Box::new(index))
    },
    "(" <Expression> ")",
};

Identifier = ID;
