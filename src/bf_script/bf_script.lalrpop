use std::str::FromStr;
use crate::bf_script::ast::{Expression, Opcode, Statement};
use lalrpop_util::ParseError;

grammar;

pub Program : Vec<Statement<'input>> = {
    <v:statement*> => v
}

statement: Statement<'input> = {
    var_declaration,
    "{" <s:statement+> "}" => Statement::Block(s),
};

var_declaration: Statement<'input> = {
    "var" <n:identifier> "=" <i: expression> ";" => Statement::VarDeclaration(n, vec![i]),
    "var" <n:identifier> "[" "]" "=" "[" <mut i: (<expression> ",")+> <t:expression> "]" ";" => {
        i.push(t);
        Statement::VarDeclaration(n, i)
    },
//    "var" <n:identifier> "[" "]" "=" "\"" <i:"foo"> "\"" ";" =>
//        Statement::VarDeclaration(n, i.chars().map(|c| Expression::Literal(c as i32)).collect()),
};

identifier = r"[a-zA-Z_]\w*";



pub expression: Expression<'input> = {
    <l:expression> <op:r"[\+\-]"> <r:factor> => Expression::Binary(Box::new(l), op.into(), Box::new(r)),
    factor,
};

factor: Expression<'input> = {
    <l:factor> <op:r"[\*\/]"> <r:term> => Expression::Binary(Box::new(l), op.into(), Box::new(r)),
    term,
};

term: Expression<'input> = {
    literal,
    "(" <expression> ")",
};

literal: Expression<'input> = {
    r"[0-9]+" => Expression::Literal(i32::from_str(<>).unwrap()),
}