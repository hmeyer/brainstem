use std::str::FromStr;
use crate::bf_script::ast::{Expression, Opcode, Statement};
use lalrpop_util::ParseError;

grammar;


match {
    r"[0-9]+" => NUMBER,
    r"[\+\-]" => ADDSUB,
    r"[\*\/]" => MULDIV,
    r"[a-zA-Z_]\w*" => ID,
    r#""[^"]*""# => STRING,

    _, 

    // Skip whitespace and comments
    r"\s*" => { },
    r"//[^\n\r]*[\n\r]*" => { }, // `// comment`
    r"/\*([^\*]*\*+[^\*/])*([^\*]*\*+|[^\*])*\*/" => { }, // `/* comment */`
}

pub Program : Vec<Statement<'input>> = {
    <Statement*>,
}

Statement: Statement<'input> = {
    VarDeclaration,
    "{" <s:Statement+> "}" => Statement::Block(s),
};

VarDeclaration: Statement<'input> = {
    "var" <n:Identifier> "=" <i: Expression> ";" => Statement::VarDeclaration(n, vec![i]),
    "var" <n:Identifier> "[" "]" "=" "[" <mut i: (<Expression> ",")+> <t:Expression> "]" ";" => {
        i.push(t);
        Statement::VarDeclaration(n, i)
    },
    "var" <n:Identifier> "[" "]" "=" <i:StringLiteral> ";" =>
        Statement::VarDeclaration(n, i.chars().map(|c| Expression::Literal(c as i32)).collect()),
};

StringLiteral: &'input str = {
    <l:STRING> => l[1..l.len() -1].into()
}

Expression: Expression<'input> = {
    <l:Expression> <op:ADDSUB> <r:Factor> => Expression::Binary(Box::new(l), op.into(), Box::new(r)),
    Factor,
};

Factor: Expression<'input> = {
    <l:Factor> <op:MULDIV> <r:Primary> => Expression::Binary(Box::new(l), op.into(), Box::new(r)),
    Primary,
};


pub Primary: Expression<'input> = {
    Literal,
    Identifier => Expression::Variable(<>),
    <n:Identifier> "[" <i:Expression> "]" => Expression::IndexedVariable(n, Box::new(i)),
    "(" <Expression> ")",
};

Identifier = ID;

Literal: Expression<'input> = {
    NUMBER => Expression::Literal(i32::from_str(<>).unwrap()),
}
